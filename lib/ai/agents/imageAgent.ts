
import { GoogleGenAI } from "@google/genai";

import { getApiKey } from '../googleClient';

// --- Provider Interface ---
interface ImageProvider {
    name: string;
    generate(prompt: string): Promise<string>;
}

// --- Providers ---

const PollinationsProvider: ImageProvider = {
    name: "Pollinations",
    generate: async (prompt: string): Promise<string> => {
        // Pollinations uses a URL-based API. We encode the prompt and return the URL.
        // Format: https://pollinations.ai/p/{prompt}?width={width}&height={height}&seed={seed}
        const encodedPrompt = encodeURIComponent(prompt);
        // Using a random seed to ensure variety if the same prompt is used
        const seed = Math.floor(Math.random() * 1000000);
        return `https://pollinations.ai/p/${encodedPrompt}?width=1280&height=720&seed=${seed}&model=flux`;
    }
};

const ImagenProvider: ImageProvider = {
    name: "Imagen",
    generate: async (prompt: string): Promise<string> => {
        const apiKey = getApiKey();
        if (!apiKey) throw new Error("GEMINI_API_KEY not found");

        const ai = new GoogleGenAI({ apiKey });
        const response = await ai.models.generateImages({
            model: 'imagen-3.0-generate-001', // Updated to a generally available model if 4.0 is restricted
            prompt: prompt,
            config: {
                numberOfImages: 1,
                aspectRatio: "16:9",
            },
        });

        if (response.generatedImages && response.generatedImages.length > 0) {
            const generatedImage = response.generatedImages[0];
            if (!generatedImage.image) throw new Error("No image data returned from Imagen");

            const imgBytes = generatedImage.image.imageBytes;
            return `data:image/png;base64,${imgBytes}`;
        }
        throw new Error("No image generated by Imagen");
    }
};

const UnsplashProvider: ImageProvider = {
    name: "Unsplash",
    generate: async (prompt: string): Promise<string> => {
        // Smarter keyword extraction
        const stopWords = new Set([
            "a", "an", "the", "in", "on", "at", "to", "for", "of", "with", "by",
            "and", "or", "but", "is", "are", "was", "were", "be", "been", "being",
            "image", "photo", "picture", "show", "me", "create", "generate", "style",
            "realistic", "photorealistic", "detailed", "high", "quality", "8k", "4k",
            "cinematic", "view", "scene", "background", "foreground", "portrait"
        ]);

        // Clean and split prompt
        const words = prompt.toLowerCase()
            .replace(/[^\w\s]/g, '') // Remove punctuation
            .split(/\s+/);

        // Filter out stop words and short words
        const keywords = words.filter(word =>
            word.length > 2 && !stopWords.has(word)
        );

        // Take top 4 meaningful keywords
        const searchTerms = keywords.slice(0, 4).join(",");

        console.log(`Unsplash Fallback: Extracted keywords '${searchTerms}' from prompt '${prompt.substring(0, 30)}...'`);

        return `https://source.unsplash.com/1600x900/?${encodeURIComponent(searchTerms)}`;
    }
};

// --- Configuration ---

// You can change this to switch providers easily
const ACTIVE_PROVIDER: ImageProvider = PollinationsProvider;

// Fallback chain: Active -> Unsplash
export const imageAgent = {
    generate: async (prompt: string): Promise<string> => {
        console.log(`Generating image using ${ACTIVE_PROVIDER.name} for prompt: "${prompt.substring(0, 50)}..."`);

        try {
            return await ACTIVE_PROVIDER.generate(prompt);
        } catch (error) {
            console.error(`Error with ${ACTIVE_PROVIDER.name}:`, error);

            // If the active provider wasn't Unsplash, try Unsplash as a final fallback
            if (ACTIVE_PROVIDER.name !== "Unsplash") {
                console.log("Falling back to Unsplash...");
                return await UnsplashProvider.generate(prompt);
            }

            throw error;
        }
    }
};
